<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Example: Calculator - A thoughtful introduction to the pest parser</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="An introduction to the pest parser by implementing a Rust grammar subset">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/csv.html"><strong aria-hidden="true">1.1.</strong> Example: CSV</a></li></ol></li><li class="chapter-item expanded "><a href="../parser_api.html"><strong aria-hidden="true">2.</strong> Parser API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/ini.html"><strong aria-hidden="true">2.1.</strong> Example: INI</a></li></ol></li><li class="chapter-item expanded "><a href="../grammars/grammars.html"><strong aria-hidden="true">3.</strong> Grammars</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../grammars/peg.html"><strong aria-hidden="true">3.1.</strong> Parsing expression grammars</a></li><li class="chapter-item expanded "><a href="../grammars/syntax.html"><strong aria-hidden="true">3.2.</strong> Syntax of pest parsers</a></li><li class="chapter-item expanded "><a href="../grammars/comments.html"><strong aria-hidden="true">3.3.</strong> Comments</a></li><li class="chapter-item expanded "><a href="../grammars/built-ins.html"><strong aria-hidden="true">3.4.</strong> Built-in rules</a></li><li class="chapter-item expanded "><a href="../examples/json.html"><strong aria-hidden="true">3.5.</strong> Example: JSON</a></li><li class="chapter-item expanded "><a href="../examples/jlang.html"><strong aria-hidden="true">3.6.</strong> Example: The J language</a></li></ol></li><li class="chapter-item expanded "><a href="../precedence.html"><strong aria-hidden="true">4.</strong> Operator precedence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/calculator.html" class="active"><strong aria-hidden="true">4.1.</strong> Example: Calculator</a></li></ol></li><li class="chapter-item expanded "><a href="../examples/awk.html"><strong aria-hidden="true">5.</strong> Final project: Awk clone (WIP)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A thoughtful introduction to the pest parser</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="example-calculator"><a class="header" href="#example-calculator">Example: Calculator</a></h1>
<p>This example focuses on the practical aspect of using a Pratt parser to parse expressions using <code>pest</code>.
To illustrate this, we build a parser for simple equations, and construct an abstract syntax tree.</p>
<h2 id="precedence-and-associativity"><a class="header" href="#precedence-and-associativity">Precedence and associativity</a></h2>
<p>In a simple equation multiplication and division are evaluated first, which means they have a higher precedence.
e.g. <code>1 + 2 * 3</code> is evaluated as <code>1 + (2 * 3)</code>, if the precedence was equal it would be <code>(1 + 2) * 3</code>.
For our system we have the following operands:</p>
<ul>
<li>highest precedence: multiplication &amp; division</li>
<li>lowest precedence: addition &amp; subtraction</li>
</ul>
<p>In the expression <code>1 + 2 - 3</code>, no operator is inherently more important than the other.
Addition, subtraction, multiplication and division are evaluated from left to right,
e.g. <code>1 - 2 + 3</code> is evaluated as <code>(1 - 2) + 3</code>. We call this property left associativity. 
Operators can also be right associative. For example, we usually evaluate the statement <code>x = y = 1</code> by first 
assigning <code>y = 1</code> and <code>x = 1</code> (or <code>x = y</code>) afterwards.</p>
<p>Associativity only matters if two operators have the same precedence, as is the case with addition and subtraction for 
example. This means that if we have an expression with only additions and subtractions, we can just evaluate it from 
left to right. <code>1 + 2 - 3</code> is equal to <code>(1 + 2) - 3</code>. And <code>1 - 2 + 3</code> is equal to <code>(1 - 2) + 3</code>.</p>
<p>To go from a flat list of operands separated by operators, it suffices to define a precedence and associativity for each 
operator. With these definitions an algorithm such as Pratt parsing is able to construct a corresponding 
expression tree.</p>
<p>If you are curious to know more about how Pratt parsing is implemented, Aleksey Kladov has a
<a href="https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html">great tutorial</a> on implementing it
from scratch using Rust.</p>
<h2 id="calculator-example"><a class="header" href="#calculator-example">Calculator example</a></h2>
<p>We want our calculator to be able to parse simple equations that consist of integers and simple binary operators.
Additionally, we want to support parenthesis and unary minus.
For example:</p>
<pre><code>1 + 2 * 3
-(2 + 5) * 16
</code></pre>
<h2 id="grammar"><a class="header" href="#grammar">Grammar</a></h2>
<p>We start by defining our atoms, bits of self-contained syntax that cannot be split up into smaller parts.
For our calculator we start with just simple integers:</p>
<pre><code class="language-pest">// No whitespace allowed between digits
integer = @{ ASCII_DIGIT+ }

atom = _{ integer }
</code></pre>
<p>Next, our binary operators:</p>
<pre><code class="language-pest">bin_op = _{ add | subtract | multiply | divide }
	add = { &quot;+&quot; }
	subtract = { &quot;-&quot; }
	multiply = { &quot;*&quot; }
	divide = { &quot;/&quot; }
</code></pre>
<p>These two rules will be the input to the
<a href="https://docs.rs/pest/latest/pest/pratt_parser/struct.PrattParser.html"><code>PrattParser</code></a>. 
It expects to receive atoms separated by operators, like so: <code>atom, bin_op, atom, bin_op, atom, ...</code>.</p>
<p>Corresponding to this format, we define our rule for expressions:</p>
<pre><code class="language-pest">expr = { atom ~ (bin_op ~ atom)* }
</code></pre>
<p>This defines the grammar which generates the required input for the Pratt parser.</p>
<h2 id="abstract-syntax-tree"><a class="header" href="#abstract-syntax-tree">Abstract Syntax Tree</a></h2>
<p>We want to convert our input into an abstract syntax tree.
For this we define the following types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum Expr {
    Integer(i32),
    BinOp {
        lhs: Box&lt;Expr&gt;,
        op: Op,
        rhs: Box&lt;Expr&gt;,
    },
}

#[derive(Debug)]
pub enum Op {
    Add,
    Subtract,
    Multiply,
    Divide,
}
<span class="boring">}</span></code></pre></pre>
<p>Note the <code>Box&lt;Expr&gt;</code> required because Rust 
<a href="https://doc.rust-lang.org/book/ch15-01-box.html#enabling-recursive-types-with-boxes">does not allow unboxed recursive types</a>. </p>
<p>There is no separate atom type, any atom is also a valid expression.</p>
<h2 id="pratt-parser"><a class="header" href="#pratt-parser">Pratt parser</a></h2>
<p>The precedence of operations is defined in the Pratt parser.</p>
<p>An easy approach is to define the PrattParser as global using <a href="https://docs.rs/lazy_static/1.4.0/lazy_static/"><code>lazy_static</code></a>.</p>
<p>Adhering to standard rules of arithmetic, 
we will define addition and subtraction to have lower priority than multiplication and division, 
and make all operators left associative.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static::lazy_static! {
    static ref PRATT_PARSER: PrattParser&lt;Rule&gt; = {
        use pest::pratt_parser::{Assoc::*, Op};
        use Rule::*;

        // Precedence is defined lowest to highest
        PrattParser::new()
            // Addition and subtract have equal precedence
            .op(Op::infix(add, Left) | Op::infix(subtract, Left))
            .op(Op::infix(multiply, Left) | Op::infix(divide, Left))
    };
}
<span class="boring">}</span></code></pre></pre>
<p>We are almost there, the only thing that's left is to use our Pratt parser.
For this the <code>map_primary</code>, <code>map_infix</code>, and <code>parse</code> functions are used, the first two take functions and the third one takes an iterator over pairs.
<code>map_primary</code> is executed for every primary (atom), and <code>map_infix</code> is executed for every binop with its new left-hand
and right-hand side according to the precedence rules defined earlier.
In this example, we create an AST in the Pratt parser.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parse_expr(pairs: Pairs&lt;Rule&gt;) -&gt; Expr {
    PRATT_PARSER
        .map_primary(|primary| match primary.as_rule() {
            Rule::integer =&gt; Expr::Integer(primary.as_str().parse::&lt;i32&gt;().unwrap()),
            rule =&gt; unreachable!(&quot;Expr::parse expected atom, found {:?}&quot;, rule)
        })
        .map_infix(|lhs, op, rhs| {
            let op = match op.as_rule() {
                Rule::add =&gt; Op::Add,
                Rule::subtract =&gt; Op::Subtract,
                Rule::multiply =&gt; Op::Multiply,
                Rule::divide =&gt; Op::Divide,
                rule =&gt; unreachable!(&quot;Expr::parse expected infix operation, found {:?}&quot;, rule),
            };
            Expr::BinOp {
                lhs: Box::new(lhs),
                op,
                rhs: Box::new(rhs),
            }
        })
        .parse(pairs)

}
<span class="boring">}</span></code></pre></pre>
<p>Here's an example of how to use the parser.</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; io::Result&lt;()&gt; {
    for line in io::stdin().lock().lines() {
        match CalculatorParser::parse(Rule::equation, &amp;line?) {
            Ok(mut pairs) =&gt; {
                println!(
                    &quot;Parsed: {:#?}&quot;,
                    parse_expr(
                        // inner of expr
                        pairs.next().unwrap().into_inner()
                    )
                );
            }
            Err(e) =&gt; {
                eprintln!(&quot;Parse failed: {:?}&quot;, e);
            }
        }
    }
    Ok(())
}
</code></pre></pre>
<p>With this, we can parse the following simple equation:</p>
<pre><code>&gt; 1 * 2 + 3 / 4
Parsed: BinOp {
    lhs: BinOp {
        lhs: Integer( 1 ),
        op: Multiply,
        rhs: Integer( 2 ),
    },
    op: Add,
    rhs: BinOp {
        lhs: Integer( 3 ),
        op: Divide,
        rhs: Integer( 4 ),
    },
}
</code></pre>
<h2 id="unary-minus-and-parenthesis"><a class="header" href="#unary-minus-and-parenthesis">Unary minus and parenthesis</a></h2>
<p>So far, our calculator can parse fairly complicated expressions, but it will fail if it encounters explicit parentheses 
or a unary minus sign. Let's fix that.</p>
<h3 id="parentheses"><a class="header" href="#parentheses">Parentheses</a></h3>
<p>Consider the expression <code>(1 + 2) * 3</code>. Clearly removing the parentheses would give a different result, so we must 
support parsing such expressions. Luckily, this can be a simple addition to our <code>atom</code> rule:</p>
<pre><code class="language-diff">- atom = _{ integer }
+ atom = _{ integer | &quot;(&quot; ~ expr ~ &quot;)&quot; }
</code></pre>
<p>Earlier we said that atoms should be simple token sequences that cannot be split up further, but now an atom can contain
arbitrary expressions! The reason we are okay with this is that the parentheses mark clear boundaries for the 
expression, it will not make ambiguous what operators belong to the inner expression and which to the outer one.</p>
<h3 id="unary-minus"><a class="header" href="#unary-minus">Unary minus</a></h3>
<p>We can currently only parse positive integers, eg <code>16</code> or <code>2342</code>. But we also want to do calculations with negative intergers.
To do this, we introduce the unary minus, so we can make <code>-4</code> and <code>-(8 + 15)</code>.
We need the following change to grammar:</p>
<pre><code class="language-pest">+ unary_minus = { &quot;-&quot; }
+ primary = _{ integer | &quot;(&quot; ~ expr ~ &quot;)&quot; }
- atom = _{ integer | &quot;(&quot; ~ expr ~ &quot;)&quot; }
+ atom = _{ unary_minus? ~ primary }
</code></pre>
<p>For these last changes we've omitted the small changes to the AST and parsing logic (using <code>map_prefix</code>).</p>
<p>You can find all these details in 
the repository: <a href="https://github.com/pest-parser/book/tree/master/examples/pest-calculator">github.com/pest-parser/book/tree/master/examples/pest-calculator</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../precedence.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../examples/awk.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../precedence.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../examples/awk.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../highlight-pest.js"></script>


    </body>
</html>
