<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Parsing expression grammar - A thoughtful introduction to the pest parser</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="An introduction to the pest parser by implementing a Rust grammar subset">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="./intro.html">Introduction</a></li><li><a href="./setup.html"><strong>1.</strong> Setup</a></li><li><a href="./peg.html" class="active"><strong>2.</strong> Parsing expression grammar</a></li><li><a href="./literals.html"><strong>3.</strong> Literals</a></li><li><a href="./syntax.html"><strong>4.</strong> Syntax</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">A thoughtful introduction to the pest parser</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="peg.html#parsing expression grammar" id="parsing expression grammar"><h1>Parsing expression grammar</h1></a>
<p>Parsing expression grammar, or PEG, is the formal grammar that <em>pest</em> uses to
describe the kind of inputs it accepts. This type of grammar is similar in
concept to regular expressions with named groups with the exception that regex
is <em>generative</em>, i.e. used to generate strings, while PEG is <em>analytic</em>, i.e.
used to test whether strings match the grammar.</p>
<a class="header" href="peg.html#generative vs analytics approach" id="generative vs analytics approach"><h2>Generative vs. analytics approach</h2></a>
<p>Let's take a look at a simple regex example in order to illustrate these
concepts a bit better:</p>
<pre><code class="language-javascript">/^(a*)(a)$/
</code></pre>
<p>This regex generates a string that starts from the beginning (<code>^</code>), matches zero
or more <code>'a'</code> (<code>a*</code>), matches one <code>'a'</code> (<code>a</code>), then it makes sure it reached the
end of its input. Since this a generative definition, we can generate the string
<code>&quot;aa&quot;</code> by generating one <code>'a'</code> from the first group and the second <code>'a'</code> from
the second group.</p>
<p>If we define the same rule in pest, it will look something like this:</p>
<pre><code>soi ~ &quot;a&quot;* ~ &quot;a&quot; ~ eoi
</code></pre>
<p><code>soi</code> and <code>eoi</code> stand for start-of-input and end-of-input respectively and work
much like their regex counterparts. <code>~</code> is used in order to crate sequences,
while the rest of the syntax should be straightforward coming from the previous
example.</p>
<p>Part of the analytical approach of PEGs is the fact that they run eagerly. If we
take the example generated by the regex, the PEG variant will eagerly match both
<code>a</code>s in the <code>&quot;a&quot;*</code> expression, leaving the second <code>&quot;a&quot;</code> unsatisfied. Every
expression in PEG tries to match as much as it possibly can. And, once it
matched, it will not backtrack in order to satisfy the next expression. At
first, this may seem like a bit of a hindrance, but it offer something else in
exchange.</p>
<a class="header" href="peg.html#non-ambiguity" id="non-ambiguity"><h2>Non-ambiguity</h2></a>
<p>If a string is accepted by a PEG grammar, it is guaranteed to be matched in one
single manner. Let's take the following regex example in order to illustrate
this:</p>
<pre><code class="language-javascript">/(a*)(a*)/
</code></pre>
<p>The string <code>&quot;aaaa&quot;</code> has, theoretically, 5 different ways of being accepted in
terms of how the groups are split, namely <code>(&quot;aaaa&quot;)()</code>, <code>(&quot;aaa&quot;)(&quot;a&quot;)</code>,
<code>(&quot;aa&quot;)(&quot;aa&quot;)</code>, <code>(&quot;a&quot;)(&quot;aaa&quot;)</code>, and <code>()(&quot;aaaa&quot;)</code>. The only way the equivalent
PEG grammar can match this is by eagerly matching the whole string in the first
expression <code>(&quot;aaaa&quot;)()</code>.</p>
<a class="header" href="peg.html#choice order" id="choice order"><h2>Choice order</h2></a>
<p>In order to keep the promise of non-ambiguity, choice expressions have to be run
in a predefined order, from right to left. This has an relevant implication when
rules have overlapping beginnings. Take the following example:</p>
<pre><code>(&quot;a&quot; | &quot;ab&quot;) ~ eoi
</code></pre>
<p>This may look perfectly correct, but is in fact incapable of accepting the
string <code>&quot;ab&quot;</code>, since the first choice will match <code>&quot;a&quot;</code>, leaving <code>&quot;b&quot;</code> at the
hand of the <code>eoi</code> rule which will then fail. And, since there is no way to match
<code>&quot;ab&quot;</code>, it can be simplified to simply <code>&quot;a&quot; ~ eoi</code>. If, however, we do want to
match both, we have to make sure that the longer expression comes first:</p>
<pre><code>(&quot;ab&quot; | &quot;a&quot;) ~ eoi
</code></pre>
<p>This way, <code>&quot;ab&quot;</code> will get matched by the first expression, while <code>&quot;a&quot;</code> will fail
it, making way for the second one to match.</p>
<a class="header" href="peg.html#left-recursion" id="left-recursion"><h2>Left-recursion</h2></a>
<p>Because of their eager nature, PEGs will always start exploring possible paths
from the left. This means that, if a rules gets to run itself before making any
kind of progress, it will result in a stack-overflow. The following examples all
fail to compile:</p>
<pre><code>// Rule calls itself right away.
rule = { rule }

// Rule makes no progress before calling itself. (since &quot;&quot; always matches)
rule = { &quot;&quot; ~ rule }

// Rules indirectly left-recurse.
rule_a = { rule_b }
rule_b = { rule_a }

// Rule still causes a stack-overflow for any other input than &quot;a&quot;.
rule = { &quot;a&quot; | rule }
</code></pre>
<p>All left-recursion use cases can be rewritten in PEG using repetition or layers
of indirection, as will be seen in later chapters.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./setup.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./literals.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./setup.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./literals.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        
    <script type="text/javascript">
        var socket = new WebSocket("ws://localhost:3001");
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload(true); // force reload from server (not from cache)
            }
        };

        window.onbeforeunload = function() {
            socket.close();
        }
    </script>


        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
